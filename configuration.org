#+TITLE: Emacs Configuration
#+DESCRIPTION: My literate emacs configuration using org-mode.
#+AUTHOR: Michael Zappa

init.el uses org-babel-load-file to automatically load in the emacs-lisp
blocks. Emacs 27.x. Only tested on PopOS, that should only be relevant for EXWM (and might not even be).

* Things to Install
** Apt Packages (or equivalent)
- silversearcher-ag (projectile-ag)
- clangd (C lsp)
- texlive-latex-extra, texlive-extra-utils, texlive-fonts-extra, texlive-xetex (latex)
- libpng-dev zlib1g-dev libpoppler-glib-dev libpoppler-private-dev imagemagick (pdf-tools)
- nodejs, npm (tide-mode)
- playerctl, brightnessctl (exwm)
- cmake, libtool-bin (vterm)
- slock (exwm)
- compton or equivalent compositor (exwm)
- lua5.3, liblua5.3, liblua5.3-dev, luarocks (latex lsp for eglot)
- graphviz, sqlite3, sqlitebrowser (optional) (org-roam)
** Other Sources
- Bash Language Server: https://github.com/bash-lsp/bash-language-server (npm)
- Elixir Language Server:  https://github.com/elixir-lsp/elixir-ls
- Haskell Language Server: https://github.com/haskell/haskell-language-server (ghcup)
- OCaml Language Server:  https://github.com/ocaml/ocaml-lsp (opam)
- LaTeX Language Server: https://github.com/astoff/digestif (luarocks)
- Java Language Server: https://github.com/eclipse/eclipse.jdt.ls
- Pyright Language Server:  https://github.com/microsoft/pyright (npm)
- Palantir Language Server: https://github.com/palantir/python-language-server (pip)
- rust-analyzer:  https://rust-analyzer.github.io/manual.html#installation
* Packages Setup
  Setting up the package archives and the lisp to automatically load all my packages.
  #+begin_src emacs-lisp
    ;; errors getting archives in Debian 10 for some emacs 26.x errors.
    (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")

    ;; setting up the MELPA and other repos
    (require 'package)
    (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
    (add-to-list 'package-archives '("melpa" . "https://stable.melpa.org/packages/") t)
    (add-to-list 'package-archives '("melpa-unstable" . "https://melpa.org/packages/") t)
    (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)

    (setq package-archive-priorities
          '(("melpa" . 50)
            ("gnu" . 10)
            ("org" . 10)
            ("melpa-unstable" . 1)))

    ;; install use-package if not installed
    (when (not (package-installed-p 'use-package))
      (package-refresh-contents)
      (package-install 'use-package))

    (unless package-archive-contents
      (package-refresh-contents))

    ;; ensure use-package by default
    (require 'use-package-ensure)
    (setq use-package-always-ensure t)

    ;; compile packages
    (use-package auto-compile
      :config (auto-compile-on-load-mode))

    ;; use newest version of packages
    (setq load-prefer-newer t)
  #+end_src
* Personal
  Giving emacs my information.
  #+begin_src emacs-lisp
    (setq user-emacs-directory "~/.emacs.d/user-dir"
          custom-file          "~/.emacs.d/custom.el"
          bookmark-default-file "~/.emacs.d/bookmarks.el"
          abbrev-file-name     "~/.emacs.d/abbrev_defs"

          user-full-name       "Michael Zappa"
          user-mail-address    "zapprich@gmail.com")
  #+end_src
* Misc
  Miscellanious things which might be put somewhere else eventually.
  #+begin_src emacs-lisp
    ;; scroll compilation output in the window
    (setq compilation-scroll-output t)

    ;; pretty symbols like lambda, and, and or in certain modes
    (global-prettify-symbols-mode t)

    ;; reduce the frequency of garbage collection by making it happen on
    ;; each 50MB of allocated data (the default is on every 0.76MB)
    (setq gc-cons-threshold 50000000)

    ;; warn when opening files bigger than 100MB
    (setq large-file-warning-threshold 100000000)

    ;; quit Emacs directly even if there are running processes
    (setq confirm-kill-processes nil)

    ;; enable y/n answers
    (fset 'yes-or-no-p 'y-or-n-p)

    ;; reload files from disk
    (global-auto-revert-mode)

    ;; don't overwrite outside program item on clipboard when switching to emacs
    (setq save-interprogram-paste-before-kill t)

    ;; add newline at end of files by default, required by some modes
    (setq mode-require-final-newline 'visit-save)

    ;; recent file store
    (recentf-mode 1)
    (setq recentf-max-menu-items 25)
    (setq recentf-max-saved-items 25)

    ;; store all backup and autosave files in the tmp dir
    (setq backup-directory-alist
          `((".*" . ,temporary-file-directory)))
    (setq auto-save-file-name-transforms
          `((".*" ,temporary-file-directory t)))

    ;; Add color formatting to *compilation* buffer
    (add-hook 'compilation-filter-hook
              (lambda () (ansi-color-apply-on-region (point-min) (point-max))))

    ;; C-w to kill line, M-w to copy line
    (defadvice kill-region (before slick-cut activate compile)
      "When called interactively with no active region, kill a single line instead."
      (interactive
       (if mark-active
           (list (region-beginning) (region-end))
         (list (line-beginning-position) (line-beginning-position 2)))))

    (defadvice kill-ring-save (before slick-copy activate compile)
      "When called interactively with no active region, copy a single line instead."
      (interactive
       (if mark-active
           (list (region-beginning) (region-end))
         (message "Copied line")
         (list (line-beginning-position) (line-beginning-position 2)))))

    ;; utility function for opening eshell in another window
    (defun mz/eshell-other-window ()
      "Open 'eshell' in a new window."
      (interactive)
      (let ((buf (eshell)))
        (switch-to-buffer (other-buffer buf))
        (switch-to-buffer-other-window buf)))

    ;; utility to reverse the result of fill-paragraph
    (defun mz/unfill-paragraph ()
      "Turns the multiline paragraph to one line."
      (interactive)
      (let ((fill-column (point-max)))
        (fill-paragraph nil)))

    (global-set-key (kbd "M-Q") 'mz/unfill-paragraph)
  #+end_src
* User Interaction
  Packages and configuration related to user interaction.
** avy
   Enables navigation around the screen by jumpting to characters.
  #+begin_src emacs-lisp
    (use-package avy
      :config
      (global-set-key (kbd "C-;") 'avy-goto-char-2))
  #+end_src
** counsel
   Completion interface for files, M-x, etc.
  #+begin_src emacs-lisp
    (use-package counsel
      :bind
      (("C-s" . swiper)
       ("C-x C-r" . counsel-recentf)
       ("M-x" . counsel-M-x)
       ("C-x C-f" . counsel-find-file)
       ("C-x b" . ivy-switch-buffer))
      :config
      (setcdr (assoc 'counsel-M-x ivy-initial-inputs-alist) "") ;; not only prefixes
      ;; for some reason just turning on counsel-mode doesn't properly replace functions on start,
      ;; so my common uses are also bound above
      (counsel-mode 1)
      (ivy-mode 1)
      (use-package ivy-hydra))
  #+end_src
** company
 #+begin_src emacs-lisp
   ;; company for text-completion
   (use-package company
     :custom
     (company-idle-delay 0)
     (company-show-numbers t)
     :config
     (global-company-mode))

   ;; tabnine is an AI completion engine
   (use-package company-tabnine
     :after
     (company)
     :config
     (add-to-list 'company-backends 'company-tabline))
  #+end_src
** hydra
  Hydra provides the ability to create a keybinding menu to reduce redundant keypresses. I also use it for creating restricted, on-demand keymaps.
  #+begin_src emacs-lisp
    (use-package hydra
      :bind
      (("C-c f" . hydra-formatting/body)
       ("C-x t" . hydra-tab-bar/body)
       ("C-c e" . hydra-eglot/body)
       ("C-c o" . hydra-org/body)
       ("C-c r" . hydra-org-roam/body)
       ("C-c b" . hydra-org-brain/body)
       ("C-c p" . hydra-projectile/body)
       ("C-x w" . hydra-windmove/body)))
  #+end_src
** ido
More minimalist, built-in completion tool.
   #+begin_src emacs-lisp
     (use-package ido
       :bind
       ("M-x" . smex)
       :custom
       (ido-enable-flex-matching t)
       (ido-everywhere t)
       (ido-use-filename-at-point 'guess)
       (ido-create-new-buffer 'always)
       :config
       (smex-initialize)
       (ido-mode 0))

     ;; display the results of ido vertically, more intuitive and readable for me
     (use-package ido-vertical-mode
       :config
       (ido-vertical-mode 1)
       (setq ido-vertical-define-keys 'C-n-and-C-p-only))

     (use-package ido-completing-read+
       :config
       (ido-ubiquitous-mode 1))
   #+end_src
** exec-path-from-shell
   Package to feed emacs by shell path on startup.
  #+begin_src emacs-lisp
    (use-package exec-path-from-shell
      :config
      (exec-path-from-shell-initialize))
  #+end_src
** smex
   An M-x enhancer which ties in with counsel.
  #+begin_src emacs-lisp
    (use-package smex)
  #+end_src
** scratch
   Opens up a new scratch buffer in the mode of the current buffer.
   #+begin_src emacs-lisp
     (use-package scratch
       :bind ("C-c s" . scratch))
   #+end_src
** undo-tree
   Dealing with undo/redo in a tree structure, enables visualization of said tree.
   #+begin_src emacs-lisp
     (use-package undo-tree
       :config
       (global-undo-tree-mode))
   #+end_src
** which-key
   Shows possible key combinations for multi-chord bindings.
  #+begin_src emacs-lisp
    (use-package which-key
      :config
      (which-key-mode))
  #+end_src
** windmove
   Navigate between windows using keyboard.
  #+begin_src emacs-lisp
    (use-package windmove
      ;; default keybindings are S-s-<direction>, but super doesn't get past GNOME shell
      :bind
      (("C-S-<left>" . windmove-swap-states-left)
       ("C-S-<right>" . windmove-swap-states-right)
       ("C-S-<up>" . windmove-swap-states-up)
       ("C-S-<down>" . windmove-swap-states-down))
      :config
      ;; use shift + arrow keys to switch between visible buffers
      (windmove-default-keybindings))

    (defhydra hydra-windmove (:color red)
      "Windmove Operations"
      ("<left>" windmove-left "left" :column "Change window")
      ("<right>" windmove-right "right")
      ("<up>" windmove-up "up")
      ("<down>" windmove-down "down")

      ("C-<left>" windmove-swap-states-left "move left" :column "Move window")
      ("C-<right>" windmove-swap-states-right "move right")
      ("C-<up>" windmove-swap-states-up "move up")
      ("C-<down>" windmove-swap-states-down "move down")

      ("q" nil "exit" :color blue))
  #+end_src
* User Interface
  Packages and configuration related to modifying the user-interface.
** all-the-icons
   Font package for more emacs icons which are used in some packages
  #+begin_src emacs-lisp
    (use-package all-the-icons)
  #+end_src
** default-text-scale
   Package for modifying the text scale, as well as setting my preferred startup value.
   #+begin_src emacs-lisp
     (set-face-attribute 'default nil :height 141)

     (use-package default-text-scale
       :config
       (default-text-scale-mode))
   #+end_src
** tab-bar-mode
   #+begin_src emacs-lisp
     ;; no GUI element unless turned on
     (setq tab-bar-show nil)

     (global-set-key (kbd "M-[") 'tab-bar-history-back)
     (global-set-key (kbd "M-]") 'tab-bar-history-forward)

     ;; hydra bindings for tab-bar-mode
     (defhydra hydra-tab-bar (:color red)
       "Tab Bar Operations"
       ("t" tab-new "Create a new tab" :column "Creation")
       ("d" dired-other-tab "Open Dired in another tab")
       ("f" find-file-other-tab "Find file in another tab")
       ("0" tab-close "Close current tab")
       ("m" tab-move "Move current tab" :column "Management")
       ("r" tab-rename "Rename Tab")
       ("<return>" tab-bar-select-tab-by-name "Select tab by name" :column "Navigation")
       ("<right>" tab-next "Next Tab")
       ("<left>" tab-previous "Previous Tab")
       ("SPC" tab-bar-mode "Toggle tab-bar-mode" :color blue :column "Misc")
       ("q" nil "exit" :color blue))
   #+end_src
** Startup Configuration
  #+begin_src emacs-lisp
    ;; scratch screen
    (setq inhibit-startup-screen t)
    (setq initial-scratch-message "")

    ;; turn off the hecking bell
    (setq ring-bell-function 'ignore)

    ;; shallow tabs
    (setq-default tab-width 2)

    ;; <tab> inserts spaces by default
    (setq-default indent-tabs-mode nil)

    ;; turn off things
    (menu-bar-mode -1)
    (scroll-bar-mode -1)
    (tool-bar-mode -1)
    (blink-cursor-mode -1)

    ;; initial frame maximized
    (add-to-list 'initial-frame-alist '(fullscreen . maximized))
  #+end_src
** Appearance
*** Themes
  #+begin_src emacs-lisp
    ;; restrained themes designed for readability.
    (use-package modus-themes
      :init
      (modus-themes-load-themes)
      :custom
      (modus-themes-intense-hl-line t)
      :config
      (modus-themes-load-vivendi)
      :bind
      ("C-c T" . modus-themes-toggle))
  #+end_src
*** minions
    #+begin_src emacs-lisp
      ;; turns off all minor modes in modeline
      (use-package minions
        :custom
        (minions-mode-line-lighter "")
        (minions-mode-line-delimiters '("" . ""))
        :config
        (minions-mode 1))
  #+end_src
** Frame Configuration
  #+begin_src emacs-lisp
    ;; more useful frame title, that show either a file or a
    ;; buffer name (if the buffer isn't visiting a file)
    (setq frame-title-format '((:eval (projectile-project-name))))

    ;; line numbers, column number, size indication
    (global-display-line-numbers-mode)
    (line-number-mode t)
    (column-number-mode t)
    (size-indication-mode t)

    ;; winner-mode to undo and redo window configurations
    (winner-mode)
  #+end_src
* Mouse and Keys
  Mouse and keyboard settings which don't belong to any specific package.
  #+begin_src emacs-lisp
    ;; scrolling
    (setq scroll-margin 0
          mouse-wheel-progressive-speed nil
          scroll-conservatively 100000
          scroll-preserve-screen-position 1)

    ;; change font size binding
    (global-set-key (kbd "C-+") 'text-scale-increase)
    (global-set-key (kbd "C--") 'text-scale-decrease)

    ;; keybinding to reload configuration
    (global-set-key (kbd "C-c m") (lambda () (interactive) (load-file "~/.emacs.d/init.el")))

    ;; keybinding to open configuration file (this file)
    (global-set-key (kbd "C-c n") (lambda ()  (interactive) (find-file "~/.emacs.d/configuration.org")))

    ;; assume I want to close current buffer with ""C-x k""
    (global-set-key (kbd "C-x k") (lambda () (interactive) (kill-buffer (current-buffer))))

    ;; shortcut to open eshell in another window. mimics that to open vterm in another window
    (global-set-key (kbd "C-M-<return>") 'mz/eshell-other-window)

    ;; shortcut to view definition of functions
    (global-set-key (kbd "C-h C-f") 'find-function)
  #+end_src
* Languages and LSP Support
  Packages and configuration related to language major/minor modes and language servers.
** Eglot
   #+begin_src emacs-lisp
     (use-package eglot)

     (defhydra hydra-eglot (:color red)
       ("r" eglot-rename "rename")
       ("e" eglot "connect")
       ("d" eglot-find-declaration "declaration")
       ("i" eglot-find-implementation "implementation")
       ("X" eglot-shutdown "shutdown")
       ("R" eglot-reconnect "reconnect")
       ("f" eglot-format "format")
       ("c" eglot-code-actions "code actions")

       ("q" nil "exit" :color blue))
   #+end_src
** Bash
   #+begin_src emacs-lisp
     (add-hook 'sh-mode-hook 'eglot-ensure)
   #+end_src
** C
  #+begin_src emacs-lisp
    (add-hook 'c-mode-hook 'eglot-ensure)
    ;; use '//' comments instead of '/* */' comments in C-mode
    (add-hook 'c-mode-hook (lambda () (c-toggle-comment-style -1)))
    (add-to-list 'eglot-server-programs '((c++-mode c-mode) "clangd"))
  #+end_src
** Common Lisp
   #+begin_src emacs-lisp
     (use-package slime
       :custom
       (inferior-lisp-program "sbcl"))
   #+end_src
** Elisp
  #+begin_src emacs-lisp
    ;; Help for emacs-lisp functions
    (use-package eldoc
      :defer t
      :hook
      ((emacs-lisp-mode lisp-interaction-mode ielm-mode) . eldoc-mode))
  #+end_src
** Elixir
  #+begin_src emacs-lisp
    ;; Elixir major mode hooked up to lsp
    (use-package elixir-mode
      :hook (elixir-mode . eglot-ensure))

    ;; minor mode for mix commands
    (use-package mix
      :hook (elixir-mode mix-minor-mode))
  #+end_src
** Haskell
   #+begin_src emacs-lisp
     (use-package haskell-mode
       :hook (haskell-mode . eglot-ensure))
   #+end_src
** OCaml
  #+begin_src emacs-lisp
    ;; OCaml major mode
    (use-package tuareg
      :hook (tuareg-mode . eglot-ensure))

    ;; dune integration, don't know how to use
    (use-package dune)
  #+end_src
** Java
  #+begin_src emacs-lisp
    (add-hook 'java-mode-hook 'eglot-ensure)

    ;; function to build jar from maven project
    (defun mz/mvn-jar ()
      "Packages the maven project into a jar."
      (interactive)
      (mvn "package"))

    ;; function to run the main class defined for the maven project
    (defun mz/mvn-run ()
      "Run the maven project using the exec plugin."
      (interactive)
      (mvn "compile exec:java"))

    ;; function to test all test classes
    (defun mz/mvn-test-all ()
      "Run all test classes in the maven project."
      (interactive)
      (mvn "test"))

    ;; maven minor mode
    (use-package mvn
      :bind
      (:map java-mode-map
            (("C-c M" . mvn)
             ("C-c m r" . mz/mvn-run)
             ("C-c m c" . mvn-compile)
             ("C-c m T" . mvn-test) ;; asks for specific test class to run
             ("C-c m t" . mz/mvn-test-all)
             ("C-c m j" . mz/mvn-jar))))
   #+end_src
** Python
  #+begin_src emacs-lisp
    (add-to-list 'eglot-server-programs '(python-mode "pyright-langserver" "--stdio"))

    (use-package python
      :hook
      (python-mode . eglot-ensure)
      :custom
      (python-indent-offset 4)
      :config
      (cond
       ;; i use python3
       ((executable-find "python3")
        (setq python-shell-interpreter "python3"))))
  #+end_src
** Racket
   #+begin_src emacs-lisp
     (use-package racket-mode)
   #+end_src
** Rust
  #+begin_src emacs-lisp
    ;; tell eglot to use the rust-analyzer binary as the language server
    (add-to-list 'eglot-server-programs '(rust-mode "rust-analyzer"))

    ;; hook up rust-mode with the language server
    (use-package rust-mode
      :custom
      (rust-format-on-save t)
      :hook (rust-mode . eglot-ensure))

    ;; cargo minor mode for cargo keybindings
    (use-package cargo
      :hook (rust-mode . cargo-minor-mode))
  #+end_src
** Ruby
   #+begin_src emacs-lisp
     (use-package ruby-mode)
     (use-package robe
       :hook
       (ruby-mode . robe-mode)
       :config
       (add-to-list 'company-backends 'company-robe))
   #+end_src
** Web Dev
Currently not doing web development, by my estimation I will need these basic packages.
   #+begin_src emacs-lisp
     ;; (use-package web-mode)
     ;; (use-package typescript-mode)
     ;; (use-package tide)
   #+end_src
* Project Management
  Packages and configuration related to managing projects.
** magit
   Excellent interface for Git.
  #+begin_src emacs-lisp
    (use-package magit
      :custom
      (magit-completing-read-function 'ivy-completing-read)
      :bind
      ("C-x g" . magit))
  #+end_src
** projectile
   Manages projects, configure common keybindings into a hydra.
  #+begin_src emacs-lisp
    ;; project manager
    (use-package projectile
      :init
      (use-package ag)
      (use-package ibuffer-projectile)
      :custom
      (projectile-completion-system 'ivy)
      (projectile-mode-line "Projectile")
      :config
      (projectile-mode +1))

    ;; hydra bindings for projectile
    (defhydra hydra-projectile (:color red)
      "PROJECTILE: %(projectile-project-root)"

      ("f"  projectile-find-file "file" :column "Find File")
      ("r"   projectile-recentf "recent file")
      ("d"   projectile-find-dir "dir")

      ("b"   projectile-switch-to-buffer "switch to buffer" :column "Buffers")
      ("i"   projectile-ibuffer "ibuffer")
      ("K"   projectile-kill-buffers "kill all buffers")
      ("e"   projectile-run-eshell "eshell" :color blue)

      ("c"   projectile-invalidate-cache "clear cache" :column "Cache (danger)")
      ("x"   projectile-remove-known-project "remove known project")
      ("X"   projectile-cleanup-known-projects "cleanup projects")
      ("z"   projectile-cache-current-file "cache current project")

      ("a"   projectile-ag "ag" :column "Project")
      ("p"   projectile-switch-project "switch project" :column "Project" :color blue)

      ("q"   nil "exit" :color blue))
  #+end_src
* Text Files
  Packages and configuration related to displaying, editing, and formatting text files.
** hl-line
  #+begin_src emacs-lisp
    ;; highlight the current line
    (use-package hl-line
      :config
      (global-hl-line-mode +1))
  #+end_src
** rainbow-mode
    Displays colors over hex color descriptions
   #+begin_src emacs-lisp
     (use-package rainbow-mode
       :hook
       (emacs-lisp-mode . rainbow-mode))
   #+end_src
** Delimiters
*** electric-pair-mode
    #+begin_src emacs-lisp
      (electric-pair-mode)
      (add-hook 'org-mode-hook
                (lambda () (setq-local electric-pair-inhibit-predicate
                                  (lambda (c)
                                    (if (eq c ?\<)
                                        t
                                      (electric-pair-inhibit-predicate c))))))
    #+end_src
*** smartparens
**** TODO figure out if I want to use smart-parens or paredit or something, don't really think I need them though
    Dealing with paren (and other delimiter) pairs.
    #+begin_src emacs-lisp
        (use-package smartparens
          :config
          (require 'smartparens-config)
          ;; (smartparens-global-mode)
          (show-smartparens-global-mode))
   #+end_src
*** rainbow-delimiters
   #+begin_src emacs-lisp
     (use-package rainbow-delimiters
       :hook
       ((prog-mode) . rainbow-delimiters-mode))
   #+end_src
** format-all
   #+begin_src emacs-lisp
     (use-package format-all)
   #+end_src
** markdown-mode
   #+begin_src emacs-lisp
     (use-package markdown-mode)
   #+end_src
** Formatting Configuration
   #+begin_src emacs-lisp
     ;; wraps visual lines
     (global-visual-line-mode)

     ;; newline at end of file
     (setq require-final-newline t)

     ;; wrap lines at 80 characters
     (setq-default fill-column 100)

     ;; delete trailing whitespace when saving.
     (add-hook 'before-save-hook 'delete-trailing-whitespace)

     ;; function for toggling comments
     (defun mz/comment-or-uncomment-region-or-line ()
       "Comments or uncomments the region or the current line if there's no active region."
       (interactive)
       (let (beg end)
         (if (region-active-p)
             (setq beg (region-beginning) end (region-end))
           (setq beg (line-beginning-position) end (line-end-position)))
         (comment-or-uncomment-region beg end)
         (forward-line)))

     ;; binding toggle-comment to "C-."
     (global-set-key (kbd "C-.") 'mz/comment-or-uncomment-region-or-line)

     ;; function to untabify buffer
     (defun mz/untabify-buffer ()
       (interactive)
       (untabify (point-min) (point-max)))

     ;; hydra for formatting files
     (defhydra hydra-formatting (:color blue)
       "formatting"
       ("f" format-all-buffer "format-all")
       ("u" mz/untabify-buffer "untabify"))
   #+end_src
* Org Mode
  Configuration for the majestic org-mode.
** General
  #+begin_src emacs-lisp
    (setq org-directory "~/org")

    ;; bullets instead of asterisks
    (use-package org-bullets
      :hook (org-mode . org-bullets-mode))

    ;; org src blocks act more like the major mode
    (setq org-src-fontify-natively t
          org-src-tab-acts-natively t

          ;; editing source block in same window
          org-src-window-setup 'current-window

          org-support-shift-select t
          org-replace-disputed-keys t)

    ;; for the "old-school" <s-<tab> to make src blocks
    (require 'org-tempo)
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))

    ;; change tabs from org-mode
    (with-eval-after-load 'org
      (define-key org-mode-map [(control tab)] 'tab-bar-switch-to-next-tab))

    (add-hook 'org-mode-hook (lambda () (flyspell-mode)))
  #+end_src
** hydra-org
   #+begin_src emacs-lisp
     (defhydra hydra-org (:color red)
       "orgmode"
       ("c" org-capture "capture")
       ("a" org-agenda "agenda")
       ("p" org-projectile-project-todo-completing-read "projectile")
       ("q" nil "exit" :color blue))
   #+end_src
** org-agenda
   #+begin_src emacs-lisp
     (setq org-agenda-files (append org-agenda-files '("~/org")))
   #+end_src
** org-capture
   #+begin_src emacs-lisp
     (global-set-key (kbd "C-c C") 'org-capture)
     (setq org-capture-templates '())
     ;; helper function to add a template to org-capture-templates
     (defun mz/add-capture-template (template)
       (let ((key (car template)))
         (setq org-capture-templates
               (cl-remove-if (lambda (x) (equal (car x) key)) org-capture-templates))
         (add-to-list 'org-capture-templates
                      template)))

     ;; abstracted template for a TODO to take place on some day, like an assignment due date.
     (defun mz/todo-on-day-template ()
       "* TODO %? %^t")
   #+end_src
** org-projectile
   #+begin_src emacs-lisp
     ;; put a todo file in the directory of each projectile project and link them to org-agenda
     (use-package org-projectile
       :custom
       (require 'org-projectile)
       (org-projectile-per-filepath "todo.org")
       :config
       (setq org-agenda-files (append org-agenda-files (org-projectile-todo-files)))
       (org-projectile-per-project))
   #+end_src
* TRAMP
  Config for Emac's built-in remote file-editing client.
  #+begin_src emacs-lisp
    (require 'tramp)

    (setq tramp-default-method "ssh")

    ;; helper function to sudo a file
    (defun mz/sudo ()
      "Use TRAMP to `sudo' the current buffer"
      (interactive)
      (when buffer-file-name
        (find-alternate-file
         (concat "/sudo:root@localhost:"
                 buffer-file-name))))

    ;; attempt to speed things up
    (defadvice projectile-project-root (around ignore-remote first activate)
      (unless (file-remote-p default-directory) ad-do-it))
    (setq remote-file-name-inhibit-cache nil)
    (setq vc-ignore-dir-regexp
          (format "%s\\|%s"
                  vc-ignore-dir-regexp
                  tramp-file-name-regexp))
    (setq tramp-verbose 1)

    (add-to-list 'tramp-remote-path "~/.local/bin")
  #+end_src
* VTerm
  Preferred emacs terminal emulator.
  #+begin_src emacs-lisp
    (setq vterm-module-cmake-args "-DUSE_SYSTEM_LIBVTERM=no")
    (use-package vterm
      :bind
      ("M-RET" . vterm-other-window)
      :config
      ;; if the fish shell is installed, use that for VTerm's shell
      (when (executable-find "fish")
        (setq vterm-shell (executable-find "fish"))))
  #+end_src
* Elfeed RSS Reader
  RSS reader using an org-mode file for configuration.
  #+begin_src emacs-lisp
    (use-package elfeed
      :bind ("C-c w" . elfeed)
      :init
      (use-package elfeed-org)
      :config
      (elfeed-org))
  #+end_src
* Nov EPub Reader
  EPub reader mode.
  #+begin_src emacs-lisp
    (use-package nov
      :config
      (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
      :hook
      (nov-mode . visual-line-mode))
  #+end_src
* LaTeX
  Packages and configuration related to editing tex files and compiling them using LaTeX.
  #+begin_src emacs-lisp
    (use-package auctex
      :defer t
      :hook ((LaTeX-mode . eglot-ensure)
             (LaTeX-mode . visual-line-mode)
             (LaTeX-mode . flyspell-mode)
             (LaTeX-mode . LaTeX-math-mode))
      :custom
      (TeX-auto-save t)
      (TeX-byte-compile t)
      (TeX-clean-confirm nil)
      (TeX-master 'dwim)
      (TeX-parse-self t)
      (TeX-source-correlate-mode t)

      ;; pdf mode
      (TeX-PDF-mode t)
      (TeX-view-program-selection '((output-pdf "PDF Tools")))
      (TeX-view-program-list '(("PDF Tools" TeX-pdf-tools-sync-view)))
      (TeX-source-correlate-start-server t)

      (reftex-plug-into-AUCTeX t)
      (TeX-error-overview-open-after-TeX-run t)
      :config
      ;; to have the buffer refresh after compilation. can't be in :hook since it's not a mode hook
      (add-hook 'TeX-after-compilation-finished-functions
                #'TeX-revert-document-buffer))

    ;; reference management, not terribly sure how to use.
    (use-package bibtex
      :after auctex
      :hook (bibtex-mode . my/bibtex-fill-column)
      :preface
      (defun mz/bibtex-fill-column ()
        "Ensures that each entry does not exceed 120 characters."
        (setq fill-column 120)))
  #+end_src
* Quelpa
A different wrapper for package.el that can also take packages from source.
#+begin_src emacs-lisp
  (use-package quelpa)

  (quelpa
   '(quelpa-use-package
     :fetcher git
     :url "https://github.com/quelpa/quelpa-use-package.git"))
  (require 'quelpa-use-package)
#+end_src
* PDF-Tools
  Prefered PDF viewer.
  #+begin_src emacs-lisp
    (use-package pdf-tools
      :init
      (pdf-tools-install)
      :hook (pdf-view-mode . pdf-view-midnight-minor-mode))

    ;; bit of a bodge to smoothly scroll through pdfs using multiple buffers
    (use-package pdf-continuous-scroll-mode
      :defer t
      :quelpa (pdf-continuous-scroll-mode
         :fetcher git
         :url "https://github.com/dalanicolai/pdf-continuous-scroll-mode.el.git")
      :hook
      (pdf-view-mode . pdf-continuous-scroll-mode)
      :custom
      (pdf-view-have-image-mode-pixel-vscroll t))
  #+end_src
* EXWM
  Configuration for using emacs as an X window manager.
  #+begin_src emacs-lisp
    ;; should exwm be enabled?
    (setq exwm-enabled (and (eq window-system 'x)
                            (seq-contains command-line-args "--use-exwm")))

    (use-package exwm
      :if exwm-enabled
      :init
      ;; package to manage bluetooth from emacs
      (use-package bluetooth)
      ;; mode to bind media keys
      (use-package desktop-environment
        :custom
        ;; for some reason the default volume commands do not work
        (desktop-environment-volume-toggle-command       "amixer -D pulse set Master toggle")
        (desktop-environment-volume-set-command          "amixer -D pulse set Master %s")
        (desktop-environment-volume-get-command          "amixer -D pulse get Master")
        ;; brightness change amount
        (desktop-environment-brightness-normal-increment "5%+")
        (desktop-environment-brightness-normal-decrement "5%-")
        (desktop-environment-brightness-small-increment  "2%+")
        (desktop-environment-brightness-small-decrement  "2%-"))
      :custom
      (exwm-workspace-number 2)
      (exwm-randr-workspace-monitor-plist
       '(0 "eDP-1" ;; laptop
           1 "DP-3")) ;; external monitor via HDMI which is for some reason named DP-3
      ;; these keys should always pass through to emacs
      (exwm-input-prefix-keys
       '(?\C-x
         ?\C-u
         ?\C-h
         ?\C-g
         ?\M-x
         ?\M-!))
      ;; set up global key bindings.  these always work, no matter the input state!
      ;; keep in mind that changing this list after EXWM initializes has no effect.
      (exwm-input-global-keys
            `(
              ;; reset to line-mode (C-c C-k switches to char-mode via exwm-input-release-keyboard)
              ([?\s-r] . exwm-reset)

              ;; general app launcher
              ([?\s-/] . (lambda ()
                           (interactive)
                           (counsel-linux-app)))

              ;; shortcut for firefox
              ([?\s-x] . (lambda ()
                           (interactive)
                           (shell-command "firefox")))

              ;; shortcut for terminal emulator
              ([s-return] . (lambda ()
                              (interactive)
                              (vterm-other-window)))))
      :config
      (desktop-environment-mode)
      ;; when window "class" updates, use it to set the buffer name
      (defun mz/exwm-update-class ()
        (exwm-workspace-rename-buffer exwm-class-name))
      (add-hook 'exwm-update-class-hook #'mz/exwm-update-class)

      ;; enable the next key to be sent directly, for things like copy and paste from x windows
      (define-key exwm-mode-map [?\C-m] 'exwm-input-send-next-key))

    ;; function to turn on all the exwm stuff
    (defun mz/enable-exwm ()
      "Enables the features of EXWM."

      ;; ensure screen updates with xrandr will refresh EXWM frames
      (require 'exwm-randr)
      (exwm-randr-enable)

      ;; use default super+shift keybindings
      (windmove-swap-states-default-keybindings)

      ;; remap capsLock to ctrl
      (start-process-shell-command "xmodmap" nil "xmodmap ~/.emacs.d/exwm/xmodmap")

      ;; display time
      (setq display-time-default-load-average nil)
      (display-time-mode t)

      ;; Show battery status in the mode line
      (display-battery-mode 1)

      (exwm-enable)
      (exwm-init))

    (if exwm-enabled (mz/enable-exwm) ())
  #+end_src
